package lockstep

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
	"net/url"
	"reflect"
	"testing"
	"time"

	"github.com/heroku/cedar/lib/optional"
	"github.com/heroku/cedar/lib/testlog"
)

var (
	testNow      = time.Now()
	sampleRecord = &Dyno{
		TXID:             194926765,
		Since:            "194926765",
		Active:           true,
		ID:               "fb47ef38-65c0-4f18-9a46-f3c97ca5d293",
		ServiceID:        "811e8180-db4c-4d5e-bf76-735a739f812c",
		InstanceID:       optional.NewString("19375"),
		AppID:            4455847,
		AppUUID:          "87ecc5d7-571d-4801-a499-da9df787f8a4",
		ReleaseID:        4,
		ReleaseUUID:      "a1eaf0ff-4eba-47bc-8c78-aa407366fb07",
		RouteID:          "71302ace-61c2-48db-ae4c-13e9213c098a",
		ProcessName:      "web.1",
		State:            "up",
		DynoSize:         "PX",
		AvailabilityZone: optional.NewString("us-east-1a"),
		IPAddress:        optional.NewString("10.145.240.43"),
		Port:             optional.NewString("11626"),
		CreatedAt:        1406090453,
		UpdatedAt:        1406090456,
		DeletedAt:        nil,
		DynoType:         "Hobby",
		Management:       "formation",
		Command:          "bundle exec rake",
		ExitStatus:       nil,
		ReceivedAt:       testNow,
	}
)

func TestNext(t *testing.T) {
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
		w.(http.Flusher).Flush()

		v, _ := json.Marshal(sampleRecord)
		w.Write(v)
		w.Write([]byte("\n"))
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := NewDynoClient(uri, WithNow(func() time.Time { return testNow })).(*dynoClient)
	go client.Run(context.Background())

	r, err := client.Next(context.Background())
	if err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(r, sampleRecord) {
		t.Fatalf("got %+v, want %+v", r, sampleRecord)
	}
}
func TestNextWithNoRetriesStreamsOnlyOnce(t *testing.T) {
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
		w.(http.Flusher).Flush()

		v, _ := json.Marshal(sampleRecord)
		w.Write(v)
		w.Write([]byte("\n"))
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := NewDynoClient(uri, WithNow(func() time.Time { return testNow })).(*dynoClient)
	go client.Run(context.Background())

	_, err := client.Next(context.Background())
	if err != nil {
		t.Fatal(err)
	}

	// Second Next call should block, and we should get a deadline.
	ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond)
	defer cancel()

	_, err = client.Next(ctx)
	if err != context.DeadlineExceeded {
		t.Fatalf("got err %v want %v", err, context.DeadlineExceeded)
	}
}
func TestNextWithContextCanceledHardFailsAndSkipsReporting(t *testing.T) {
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusInternalServerError)

		t.Errorf("lockstep handler called with canceled context")
	})
	s := httptest.NewServer(h)
	defer s.Close()

	metricsHook, check := makeMetricsHook()
	logger, hook := testlog.NewNullLogger()

	uri, _ := url.Parse(s.URL)
	client := NewDynoClient(uri,
		WithErrorHook(func(err error) { logger.WithError(err).Error() }),
		WithMetricsHook(metricsHook),
		WithConstantBackoff(1, time.Second),
	).(*dynoClient)

	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	done := make(chan struct{})
	go func() {
		client.Run(ctx)
		close(done)
	}()

	nextDone := make(chan struct{})
	go func() {
		_, err := client.Next(context.Background())
		if err != io.EOF {
			t.Errorf("got err %v want io.EOF", err)
		}
		close(nextDone)
	}()

	<-nextDone
	<-done

	// We still want errors to be logged
	hook.CheckContained(t, "error with lockstep request")
	hook.CheckContained(t, "context canceled")

	// But we don't want them emitted for metrics.
	check(t, MetricTypeDialError, 0)

	// Got 0 stream events.
	check(t, MetricTypeStreamReceiveTotal, 0)
	check(t, MetricTypeStreamReceiveError, 0)
}

// a client with no retries enabled will return the first error in Start. The
// call to Next will return an EOF.
func TestNextBackoffErrorHandlingBehavior(t *testing.T) {
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusInternalServerError)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	metricsHook, check := makeMetricsHook()

	l, hook := testlog.NewNullLogger()
	errorHook := func(err error) {
		l.WithError(err).Error()
	}

	done := make(chan struct{})
	uri, _ := url.Parse(s.URL)
	client := NewDynoClient(uri,
		WithMetricsHook(metricsHook),
		WithErrorHook(errorHook),
	).(*dynoClient)

	go func() {
		wantError := unexpectedCodeError{uri.String(), 202, 500}
		if err := client.Run(context.Background()); err != wantError {
			t.Fatalf("got error %v want %v", err, wantError)
		}
		close(done)
	}()

	_, err := client.Next(context.Background())
	if err != io.EOF {
		t.Fatalf("got err: %v want %v", err, io.EOF)
	}

	check(t, MetricTypeDialTotal, 1)
	check(t, MetricTypeDialError, 1)
	hook.CheckContained(t, "expected 202 got 500")

	<-done
}

func TestNextWithBackoffSkipsOverErrors(t *testing.T) {
	record1 := &Dyno{
		TXID:       2,
		Since:      "2",
		ReceivedAt: testNow,
	}

	record2 := &Dyno{
		TXID:       3,
		Since:      "3",
		ReceivedAt: testNow,
	}

	reqSeq := -1
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		reqSeq++

		switch reqSeq {
		case 0: // intermittent error 1
			w.WriteHeader(http.StatusInternalServerError)
		case 1: // sample record1
			if got := r.URL.Query().Get("since"); got != "1" {
				t.Fatalf("got since %v want %v", got, "1")
			}

			w.Header().Set("Transfer-Encoding", "chunked")
			w.WriteHeader(http.StatusAccepted)
			w.(http.Flusher).Flush()

			v, _ := json.Marshal(record1)
			w.Write(v)
			w.Write([]byte("\n"))

		case 2: // intermittent error 2
			w.WriteHeader(http.StatusInternalServerError)

		case 3: // broken JSON
			if got := r.URL.Query().Get("since"); got != "2" {
				t.Fatalf("got since %v want %v", got, "2")
			}

			w.Header().Set("Transfer-Encoding", "chunked")
			w.WriteHeader(http.StatusAccepted)
			w.(http.Flusher).Flush()
			w.Write([]byte(`1` + "\n"))

		case 4: // record2
			if got := r.URL.Query().Get("since"); got != "2" {
				t.Fatalf("got since %v want %v", got, "2")
			}

			w.Header().Set("Transfer-Encoding", "chunked")
			w.WriteHeader(http.StatusAccepted)
			w.(http.Flusher).Flush()

			v, _ := json.Marshal(record2)
			w.Write(v)
			w.Write([]byte("\n"))

		default:
			w.WriteHeader(http.StatusAccepted)
			w.(http.Flusher).Flush()

			w.Write([]byte("\n"))
		}
	})

	s := httptest.NewServer(h)
	defer s.Close()

	l, hook := testlog.NewNullLogger()
	errorHook := func(err error) {
		l.WithError(err).Error()
	}

	metricsHook, check := makeMetricsHook()

	uri, _ := url.Parse(s.URL)
	client := NewDynoClient(uri,
		WithNow(func() time.Time { return testNow }),
		WithConstantBackoff(1, time.Millisecond),
		WithSince("1"),
		WithMetricsHook(metricsHook),
		WithErrorHook(errorHook),
	).(*dynoClient)

	done := make(chan struct{})
	ctx, cancel := context.WithCancel(context.Background())
	go func() {
		client.Run(ctx)
		close(done)
	}()

	r, err := client.Next(context.Background())
	if err != nil {
		t.Fatal(err)
	}

	if !reflect.DeepEqual(r, record1) {
		t.Fatalf("got %+v, want %+v", r, record1)
	}

	r, err = client.Next(context.Background())
	if err != nil {
		t.Fatal(err)
	}

	if !reflect.DeepEqual(r, record2) {
		t.Fatalf("got %+v, want %+v", r, record2)
	}

	// Ensure the Run loop is done before we test for metrics.
	cancel()
	<-done

	check(t, MetricTypeDialError, 2)
	check(t, MetricTypeStreamReceiveError, 0)
	check(t, MetricTypeStreamReceiveTotal, 5)
	check(t, MetricTypeStreamUnmarshalError, 1)

	hook.CheckContained(t, "expected 202 got 500")
	hook.CheckContained(t, "read bytes failed")
}

func TestNextIgnoresHeartbeats(t *testing.T) {
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
		w.(http.Flusher).Flush()

		w.Write([]byte(`{"heartbeat": true}`))
		w.Write([]byte("\n"))

		v, _ := json.Marshal(sampleRecord)
		w.Write(v)
		w.Write([]byte("\n"))
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := NewDynoClient(uri, WithNow(func() time.Time { return testNow })).(*dynoClient)

	go client.Run(context.Background())

	r, err := client.Next(context.Background())
	if err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(r, sampleRecord) {
		t.Fatalf("got %+v, want %+v", r, sampleRecord)
	}
}

func TestNextWithMalformedRecord(t *testing.T) {
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
		w.(http.Flusher).Flush()
		w.Write([]byte("some crap that isn't valid JSON\n"))
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := NewDynoClient(uri).(*dynoClient)

	go client.Run(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
	defer cancel()

	// We expect malformed records to be skipped, therefore we shouldn't
	// even get anything here, and we'll just expect a timeout.
	if _, err := client.Next(ctx); err != context.DeadlineExceeded {
		t.Fatalf("got %+v, want context.DeadlineExceeded", err)
	}
}
