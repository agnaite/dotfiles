package lockstep

import (
	"bufio"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"time"

	"github.com/eapache/go-resiliency/retrier"
	"github.com/heroku/cedar/lib/cleanurl"
	"github.com/pkg/errors"
)

// MetricType is the enum of all exported known events to report metrics on.
type MetricType string

const (
	// SinceEpoch is the nil sentinel that's specified when starting streams
	// from scratch.
	SinceEpoch = "0"

	// MetricTypeStreamReceiveTotal counts the total received events
	MetricTypeStreamReceiveTotal MetricType = "stream-receive-total"

	// MetricTypeStreamReceiveError counts the network receive errors
	MetricTypeStreamReceiveError MetricType = "stream-receive-error"

	// MetricTypeStreamUnmarshalError counts the malformed event errors
	MetricTypeStreamUnmarshalError MetricType = "stream-unmarshal-error"

	// MetricTypeDialTotal counts the number of times a dial was attempted
	MetricTypeDialTotal MetricType = "dial-total"

	// MetricTypeDialError counts the number of times a dial error occured
	MetricTypeDialError MetricType = "dial-error"
)

var nethttpClient = &http.Client{
	Transport: &http.Transport{
		TLSClientConfig: &tls.Config{
			// TODO(jkakar) This is bad but we need it to work with self-signed
			// certificates, such as the ones we use in staging.
			InsecureSkipVerify: true,
		},
		Dial: (&net.Dialer{
			Timeout:   3 * time.Second,
			KeepAlive: 30 * time.Second,
		}).Dial,
		TLSHandshakeTimeout: 3 * time.Second,
	},
}

// Heartbeat values keep the HTTP connection to the lockstep service open.
type heartbeat struct {
	Heartbeat bool `json:"heartbeat"`
}

// Configuration options used when initializing a client.
type options struct {
	Since         string
	QueryValues   url.Values
	ModifiedAfter string
	UserAgent     string
}

// OptionFunc is any sort of option that can configure a client.
type OptionFunc func(*httpClient)

// WithSince configures a client to stream records newer or equal to since.
func WithSince(since string) OptionFunc {
	return func(c *httpClient) {
		c.options.Since = since
	}
}

// WithProcessType configures a client to stream records for events matching name.
func WithProcessType(name string) OptionFunc {
	return func(c *httpClient) {
		if name != "" {
			c.options.QueryValues.Set("process_type", name)
		}
	}
}

// WithModifiedAfter configures a client to stream records for events modified
// after the given timestamp.
func WithModifiedAfter(modifiedAfter string) OptionFunc {
	return func(c *httpClient) {
		c.options.ModifiedAfter = modifiedAfter
	}
}

// WithUserAgent configures a client to send the User-Agent header.
func WithUserAgent(ua string) OptionFunc {
	return func(c *httpClient) {
		c.options.UserAgent = ua
	}
}

// WithConstantBackoff enables constant backoff. A good ceiling for timeouts
// would be 10s, at which we should be getting alarms all over the place.
func WithConstantBackoff(retries int, delay time.Duration) OptionFunc {
	return func(c *httpClient) {
		c.reconnect = true
		c.retrier = retrier.New(
			retrier.ConstantBackoff(retries, delay),
			canceledClassifier{},
		)
	}
}

// WithMetricsHook assigns a metrics hook.
func WithMetricsHook(h func(MetricType, float64)) OptionFunc {
	return func(c *httpClient) {
		c.metricHook = h
	}
}

// WithErrorHook assigns an error hook.
func WithErrorHook(h func(err error)) OptionFunc {
	return func(c *httpClient) {
		c.errorHook = h
	}
}

// WithNow is used as a convenience function for testing.
func WithNow(now func() time.Time) OptionFunc {
	return func(c *httpClient) {
		c.now = now
	}
}

// httpClient connects to a lockstep service to continuously fetch records.
type httpClient struct {
	url        *url.URL
	user, pass string
	resp       *http.Response
	reader     *bufio.Reader
	options    *options
	results    chan result

	retrier    *retrier.Retrier
	errorHook  func(error)
	metricHook func(MetricType, float64)
	decodeHook func([]byte, func() time.Time) (*Event, error)
	now        func() time.Time
	reconnect  bool
}

// NewhttpClient returns a Client configured to connect to the lockstep service.
func newHTTPClient(u *url.URL, opts ...OptionFunc) *httpClient {
	u, user, pass := cleanurl.ExtractCredentials(u)
	c := &httpClient{
		url:     u,
		user:    user,
		pass:    pass,
		options: &options{QueryValues: make(url.Values)},
		results: make(chan result),
		now:     time.Now,
	}

	for _, opt := range opts {
		opt(c)
	}

	// noop metricHook if none provided
	if c.metricHook == nil {
		c.metricHook = func(_ MetricType, _ float64) {}
	}

	// noop errorHook if none provided
	if c.errorHook == nil {
		c.errorHook = func(error) {}
	}

	return c
}

func (c *httpClient) dialWithRetry(ctx context.Context) error {
	dial := func(ctx context.Context) error {
		c.metricHook(MetricTypeDialTotal, 1)

		err := c.dial(ctx)
		if err != nil {
			c.errorHook(err)
			if shouldReport(err) {
				c.metricHook(MetricTypeDialError, 1)
			}
		}
		return err
	}

	if c.retrier == nil {
		return dial(ctx)
	}
	return c.retrier.Run(func() error { return dial(ctx) })
}

func (c *httpClient) dial(ctx context.Context) error {
	u, err := url.Parse(c.url.String())
	if err != nil {
		return errors.Wrap(err, "error parsing url")
	}
	u.RawQuery = queryValues(c.options)

	req, err := http.NewRequest(http.MethodGet, u.String(), nil)
	if err != nil {
		return errors.Wrap(err, "new http request failed")
	}
	req = req.WithContext(ctx)
	req.SetBasicAuth(c.user, c.pass)

	if c.options.UserAgent != "" {
		req.Header.Set("User-Agent", c.options.UserAgent)
	}

	resp, err := nethttpClient.Do(req)
	if err != nil {
		return errors.Wrap(err, "error with lockstep request")
	}
	if resp.StatusCode != http.StatusAccepted {
		resp.Body.Close()
		return unexpectedCodeError{c.url.String(), http.StatusAccepted, resp.StatusCode}
	}
	c.resp = resp
	c.reader = bufio.NewReader(resp.Body)
	return nil
}

func (c *httpClient) teardown() {
	if c.resp != nil {
		c.resp.Body.Close()
		c.resp = nil
		c.reader = nil
	}
}

// Next returns the next record from the lockstep service.
func (c *httpClient) Next(ctx context.Context) (*Event, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case r, more := <-c.results:
		if !more {
			return nil, io.EOF
		}
		if r.error != nil {
			return nil, r.error
		}
		return r.event, nil
	}
}

// Run connects to the configured lockstep server. It blocks until a hard
// failure is encountered.
func (c *httpClient) Run(ctx context.Context) error {
	for {
		c.teardown()

		if err := c.dialWithRetry(ctx); err != nil {
			close(c.results)
			return err
		}

		for {
			e, err := c.receive(ctx)
			c.metricHook(MetricTypeStreamReceiveTotal, 1)
			if err != nil {
				c.errorHook(err)
				if shouldReport(err) {
					c.metricHook(MetricTypeStreamReceiveError, 1)
				}
				break
			}

			c.pushResult(ctx, result{event: e})
			since, err := e.getSince()
			if err != nil {
				return err
			}
			c.options.Since = since
		}

		if !c.reconnect {
			return io.EOF
		}
	}
}

func (c *httpClient) pushResult(ctx context.Context, r result) {
	select {
	case <-ctx.Done():
	case c.results <- r:
	}
}

func (c *httpClient) receive(ctx context.Context) (*Event, error) {
	for {
		// Read the next line from the HTTP request.
		l, err := c.reader.ReadBytes('\n')
		if err != nil {
			return nil, errors.Wrap(err, "read bytes failed")
		}

		// Detect and skip heartbeats.
		h := &heartbeat{}
		err = json.Unmarshal(l, h)
		if err != nil {
			c.metricHook(MetricTypeStreamUnmarshalError, 1)
			continue
		}

		if h.Heartbeat {
			continue
		}

		// Load and return the record.
		e, err := c.decodeHook(l, c.now)
		if err != nil {
			c.metricHook(MetricTypeStreamUnmarshalError, 1)
			return nil, err
		}
		return e, nil
	}
}

// result is the tuple returned by Next.
type result struct {
	event  *Event
	error  error
	source string
}

// unexpectedCodeError is the error returned by dial when we get a bad erorr code.
type unexpectedCodeError struct {
	url       string
	got, want int
}

// Error implements error.
func (e unexpectedCodeError) Error() string {
	return fmt.Sprintf("%s: expected %d got %d", e.url, e.got, e.want)
}

func queryValues(opts *options) string {
	v := url.Values{}
	v.Set("heartbeat", "true")
	v.Set("update", "true")

	if opts == nil {
		return v.Encode()
	}

	// Prefer the Since value if it's set, since that's where we resume from internally
	// after retries (e.g. we do c.options.Since = since in the loop).
	if opts.Since != "" {
		v.Set("since", opts.Since)
	} else if opts.ModifiedAfter != "" {
		// This should only only happen if Since is empty, otherwise we'll get a 400.
		v.Set("modified_after", opts.ModifiedAfter)
	}

	for key, val := range opts.QueryValues {
		v[key] = val
	}

	return v.Encode()
}

func shouldReport(err error) bool {
	err = errorCause(err)

	if err == context.Canceled || err == io.ErrUnexpectedEOF || err == io.EOF {
		return false
	}
	return true
}

// errorCause is a superset of errors.Cause which tries to see if we have a
// url.Error and returns e.Err if so. We fall back to errors.Cause otherwise.
func errorCause(err error) error {
	err = errors.Cause(err)
	if e, ok := err.(*url.Error); ok {
		return e.Err
	}
	return err
}

type canceledClassifier struct{}

// Classify implements the Classifier interface.
func (c canceledClassifier) Classify(err error) retrier.Action {
	if err == nil {
		return retrier.Succeed
	}

	if errorCause(err) == context.Canceled {
		return retrier.Fail
	}
	return retrier.Retry
}
