package lockstep

import (
	"context"
	"encoding/json"
	"net/url"
	"time"

	"github.com/heroku/cedar/lib/optional"
)

// Dyno represents a physical dyno in the lockstep service.
type Dyno struct {
	TXID             int64           `json:"txid"`
	Since            string          `json:"since"`
	CreatedAt        int             `json:"created_at"`
	UpdatedAt        int64           `json:"emitted_at"`
	DeletedAt        *int            `json:"deleted_at,omitempty"`
	Active           bool            `json:"active"`
	ID               string          `json:"id"`
	ServiceID        string          `json:"service_id"`
	AppID            int64           `json:"app_id"`
	AppUUID          string          `json:"app_uuid"`
	ReleaseID        int             `json:"release_id"`
	ReleaseUUID      string          `json:"release_uuid"`
	RouteID          string          `json:"route_id"`
	InstanceID       optional.String `json:"instance_id"`
	AvailabilityZone optional.String `json:"az"`
	IPAddress        optional.String `json:"ip"`
	Port             optional.String `json:"port"`
	ProcessName      string          `json:"ps"`
	State            string          `json:"state"`
	DynoSize         string          `json:"dyno_size"`
	DynoType         string          `json:"dyno_type"`
	Command          string          `json:"command"`
	Management       string          `json:"management"`
	ExitStatus       *int            `json:"exit_status"`
	ReceivedAt       time.Time       `json:"-"`
}

// dynoClient connects to a lockstep service to continuously fetch records.
type dynoClient struct {
	*httpClient
}

// DynoClient implements a scanner-like interface to read dyno records
// from a feed.
type DynoClient interface {
	Run(context.Context) error
	Next(context.Context) (*Dyno, error)
}

// NewDynoClient returns a Client configured to connect to the lockstep service.
func NewDynoClient(u *url.URL, opts ...OptionFunc) DynoClient {
	c := &dynoClient{newHTTPClient(u, opts...)}

	// default decodeHook to use decodeDyno
	c.decodeHook = decodeDyno

	return c
}

// Next returns the next record from the lockstep service.
func (c *dynoClient) Next(ctx context.Context) (*Dyno, error) {
	e, err := c.httpClient.Next(ctx)
	if err != nil {
		return nil, err
	}
	return e.GetDyno()
}

func decodeDyno(l []byte, now func() time.Time) (*Event, error) {
	d := &Dyno{ReceivedAt: now()}
	e := &Event{Data: d}
	err := json.Unmarshal(l, d)
	return e, err
}
