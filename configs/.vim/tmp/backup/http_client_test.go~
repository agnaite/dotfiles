package lockstep

import (
	"context"
	"net/http"
	"net/http/httptest"
	"net/url"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/heroku/cedar/lib/iso8601"
)

func TestDialErrorDoesNotLeakCreds(t *testing.T) {
	s := httptest.NewServer(nil)
	s.Close()

	uri, _ := url.Parse(s.URL)
	uri.User = url.UserPassword("someuser", "somepass")

	client := newHTTPClient(uri)
	err := client.dial(context.Background())
	if err == nil {
		t.Fatal("wanted an error")
	}

	if strings.Contains(err.Error(), "someuser") {
		t.Fatalf("err %s contains user=someuser", err)
	}

	if strings.Contains(err.Error(), "somepass") {
		t.Fatalf("err %s contains pass=somepass", err)
	}
}

func TestDialWithContextCanceledHardFailsAndSkipsReporting(t *testing.T) {
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusInternalServerError)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	metricsHook, check := makeMetricsHook()

	uri, _ := url.Parse(s.URL)
	client := newHTTPClient(uri,
		WithMetricsHook(metricsHook),
		WithConstantBackoff(2, time.Second),
	)

	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	if err := client.dialWithRetry(ctx); err == nil {
		t.Fatal("got no error, wanted context.Canceled")
	}

	check(t, MetricTypeDialError, 0)
	check(t, MetricTypeDialTotal, 1)
}

func TestDial(t *testing.T) {
	query := ""
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		query = r.URL.RawQuery
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := newHTTPClient(uri)

	if err := client.dial(context.Background()); err != nil {
		t.Fatal(err)
	}
	want := "heartbeat=true&update=true"
	if query != want {
		t.Fatalf("got %+v, want %+v", query, want)
	}
}

func TestDialWithUnexpectedStatusCode(t *testing.T) {
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusNotFound)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := newHTTPClient(uri)

	err := client.dial(context.Background())
	if err == nil {
		t.Fatal("got nil, want error")
	}
	wantErr := unexpectedCodeError{uri.String(), 202, 404}
	if err != wantErr {
		t.Fatalf("got err %v want %v", err, wantErr)
	}
}

func TestDialWithNonEmptySince(t *testing.T) {
	query := ""
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		query = r.URL.RawQuery
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := newHTTPClient(uri, WithSince("19"))

	if err := client.dial(context.Background()); err != nil {
		t.Fatal(err)
	}
	want := "heartbeat=true&since=19&update=true"
	if query != want {
		t.Fatalf("got %+v, want %+v", query, want)
	}
}

func TestDialWithNonEmptySinceAndModifiedAfterChoosesSince(t *testing.T) {
	query := ""
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		query = r.URL.RawQuery
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := newHTTPClient(uri, WithSince("19"), WithModifiedAfter(time.Now().Format(iso8601.Format)))

	if err := client.dial(context.Background()); err != nil {
		t.Fatal(err)
	}
	want := "heartbeat=true&since=19&update=true"
	if query != want {
		t.Fatalf("got %+v, want %+v", query, want)
	}
}

func TestDialWithUserAgent(t *testing.T) {
	ua := ""
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ua = r.Header.Get("User-Agent")
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := newHTTPClient(uri, WithUserAgent("smith"))

	if err := client.dial(context.Background()); err != nil {
		t.Fatal(err)
	}
	want := "smith"
	if ua != want {
		t.Fatalf("got %+v, want %+v", ua, want)
	}
}

func TestDialProcessType(t *testing.T) {
	query := ""
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		query = r.URL.RawQuery
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := newHTTPClient(uri, WithProcessType("web"))

	if err := client.dial(context.Background()); err != nil {
		t.Fatal(err)
	}
	want := "heartbeat=true&process_type=web&update=true"
	if query != want {
		t.Fatalf("got %+v, want %+v", query, want)
	}
}

func TestDialProcessTypeBlank(t *testing.T) {
	query := ""
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		query = r.URL.RawQuery
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := newHTTPClient(uri, WithProcessType(""))

	if err := client.dial(context.Background()); err != nil {
		t.Fatal(err)
	}
	want := "heartbeat=true&update=true"
	if query != want {
		t.Fatalf("got %+v, want %+v", query, want)
	}
}

func TestDialModifiedAfter(t *testing.T) {
	query := ""
	h := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		query = r.URL.RawQuery
		w.Header().Set("Transfer-Encoding", "chunked")
		w.WriteHeader(http.StatusAccepted)
	})
	s := httptest.NewServer(h)
	defer s.Close()

	uri, _ := url.Parse(s.URL)
	client := newHTTPClient(uri, WithModifiedAfter("2017-01-13T12:34:56Z"))

	if err := client.dial(context.Background()); err != nil {
		t.Fatal(err)
	}
	want := "heartbeat=true&modified_after=2017-01-13T12%3A34%3A56Z&update=true"
	if query != want {
		t.Fatalf("got %+v, want %+v", query, want)
	}

}

func testShouldReport(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	req, _ := http.NewRequest("GET", "http://some-host/something", nil)
	req = req.WithContext(ctx)
	_, err := http.DefaultClient.Do(req)
	if err == nil {
		t.Fatal("wanted some error")
	}

	if !shouldReport(err) {
		t.Fatalf("wanted err to not be reported: %v", err)
	}
}

func makeMetricsHook() (func(MetricType, float64), func(*testing.T, MetricType, float64)) {
	m := make(map[MetricType]float64)
	var mutex sync.Mutex

	checker := func(t *testing.T, mt MetricType, want float64) {
		t.Helper()

		mutex.Lock()
		defer mutex.Unlock()
		if m[mt] < want {
			t.Fatalf("got %v, want %v at least for metric %v", m[mt], want, mt)
		}
	}

	hook := func(t MetricType, v float64) {
		mutex.Lock()
		defer mutex.Unlock()
		m[t] += v
	}

	return hook, checker
}
